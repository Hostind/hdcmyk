<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>HD CMYK • Pro LAB/CMYK Match Studio — Ultra Stable</title>
<style>
  :root{
    --bg:#0d0f12;--panel:#12151a;--muted:#1b2027;--text:#e9edf3;--soft:#aeb6c2;
    --accent:#67e8f9;--good:#22c55e;--warn:#f59e0b;--bad:#ef4444;--card:#0f1318;
    --chip:#2a313b;--border:#26303a
  }
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,#0b0e12 0%,#0f1217 100%);color:var(--text);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  header{position:sticky;top:0;z-index:5;background:rgba(13,15,18,.85);backdrop-filter:saturate(1.4) blur(8px);border-bottom:1px solid var(--border)}
  .wrap{max-width:2400px;margin:0 auto;padding:16px 24px}
  h1{margin:0;font-size:24px;letter-spacing:.2px;font-weight:600}
  .subtitle{color:var(--soft);font-size:13px;line-height:1.4}
  .grid{display:grid;gap:16px}
  @media(max-width:1200px){ .grid.cols-3{grid-template-columns:1fr} .grid.cols-2{grid-template-columns:1fr} .wrap{padding:12px 16px}}
  @media(min-width:1200px) and (max-width:1600px){ .grid.cols-3{grid-template-columns:1.5fr 1.2fr 1fr} .grid.cols-2{grid-template-columns:1.4fr 1fr}}
  @media(min-width:1600px) and (max-width:2000px){ .grid.cols-3{grid-template-columns:1.8fr 1.4fr 1.2fr} .grid.cols-2{grid-template-columns:1.6fr 1fr}}
  @media(min-width:2000px) and (max-width:2400px){ .grid.cols-3{grid-template-columns:2fr 1.6fr 1.4fr} .grid.cols-2{grid-template-columns:1.8fr 1.2fr}}
  @media(min-width:2400px){ .grid.cols-3{grid-template-columns:2.2fr 1.8fr 1.6fr} .grid.cols-2{grid-template-columns:2fr 1.4fr}}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:16px;padding:18px;box-shadow:0 8px 32px rgba(0,0,0,.3)}
  .card h2{margin:0 0 12px 0;font-size:18px;font-weight:600;color:#f1f5f9}
  label{display:block;margin:10px 0 4px 0;color:#c7ced9;font-size:12px}
  input,select,button,textarea{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:var(--card);color:var(--text)}
  textarea{resize:vertical}
  input[type="number"]{appearance:textfield}
  .row{display:grid;grid-template-columns:repeat(6,1fr);gap:10px}
  .row-4{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}
  .row-3{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
  .row-2{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
  @media(max-width:1200px){ .row{grid-template-columns:repeat(3,1fr)} .row-4{grid-template-columns:repeat(2,1fr)} .row-3{grid-template-columns:repeat(2,1fr)}}
  .pill{display:inline-flex;align-items:center;gap:8px;background:var(--chip);border:1px solid var(--border);padding:6px 10px;border-radius:999px;font-size:12px}
  .btn{cursor:pointer;transition:.15s transform ease,.15s opacity}
  .btn:hover{transform:translateY(-1px)}
  .btn.primary{background:linear-gradient(135deg,#2dd4bf,#60a5fa);border:none;color:#071016;font-weight:700}
  .btn.ghost{background:transparent}
  .badge{display:inline-block;padding:4px 8px;border-radius:999px;font-size:11px}
  .pass{background:rgba(34,197,94,.15);color:#7cf0a3;border:1px solid rgba(34,197,94,.35)}
  .warn{background:rgba(245,158,11,.15);color:#ffd08a;border:1px solid rgba(245,158,11,.35)}
  .fail{background:rgba(239,68,68,.15);color:#ff9b9b;border:1px solid rgba(239,68,68,.35)}
  .swatch{height:42px;border-radius:10px;border:1px solid var(--border)}
  .tiny{font-size:11px;color:#9aa3af}
  .flex{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  table{width:100%;border-collapse:collapse;border-radius:12px;overflow:hidden}
  th,td{border-bottom:1px solid var(--border);padding:8px 10px;text-align:left}
  th{font-weight:600;color:#cbd5e1;background:#0e1217}
  tr:hover td{background:#0f141a}
  .right{text-align:right}
  .danger{color:#ff8484}
  .ok{color:#8bf0b1}
  canvas{width:100%;height:220px;background:#0b0f14;border-radius:12px;border:1px solid var(--border)}
  .code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:12px}
  .muted{opacity:.8}
  .kpi{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .kpi .card{padding:10px}
  .tag{display:inline-block;background:#0b0f14;border:1px dashed var(--border);padding:2px 6px;border-radius:6px;color:#a9b1bc;font-size:11px}
  #toast{position:fixed;bottom:16px;right:16px;padding:10px 12px;border:1px solid var(--border);border-radius:10px;background:rgba(15,19,24,.95);color:var(--text);z-index:9999;transition:opacity .2s ease;opacity:0}
  /* Print */
  @media print{
    header{display:none}
    main.wrap{max-width:none}
    .card{break-inside:avoid-page}
  }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>HD CMYK — Pro LAB/CMYK Match Studio (Ultra Stable)</h1>
    <div class="subtitle">ΔE suite • Patch heatmap • CCM • Substrate simulation • Pantone/Brand library • CSV/Folder ingest • ICC soft proof • CMYKOGV • SOP • PDF reports</div>
  </div>
</header>

<main class="wrap grid cols-3" style="margin-top:12px">
  <!-- Left Column -->
  <section class="card">
    <h2>1) Target vs. Press — ΔE & Suggestions</h2>
    <div class="row-4">
      <div>
        <label>Pantone Preset</label>
        <select id="pantonePreset">
          <option value="">Select Pantone Color...</option>
        </select>
      </div>
      <div>
        <label>Substrate</label>
        <select id="substrate">
          <option value="hpw">Hot Press White</option>
          <option value="inver">Invercote</option>
          <option value="gsm250">250 gsm</option>
          <option value="foil">Foil Board</option>
        </select>
      </div>
      <div>
        <label>Illuminant / Obs.</label>
        <select id="illuminant">
          <option>D50 / 2°</option>
          <option>D50 / 10°</option>
          <option>D65 / 2°</option>
          <option>D65 / 10°</option>
        </select>
      </div>
      <div>
        <label>ΔE Tolerance</label>
        <input id="tolerance" type="number" step="0.1" value="2.0" />
      </div>
    </div>

    <div class="row-2" style="margin-top:6px">
      <div class="card" style="background:#0f141a">
        <h3 style="margin:0 0 6px 0;font-size:14px">Target (Proof) — LAB</h3>
        <div class="row-3">
          <div><label>L*</label><input id="tL" type="number" step="0.01" value="65"></div>
          <div><label>a*</label><input id="tA" type="number" step="0.01" value="12"></div>
          <div><label>b*</label><input id="tB" type="number" step="0.01" value="18"></div>
        </div>
        <div class="row" style="margin-top:6px;grid-template-columns:repeat(7,1fr)">
          <div><label>C</label><input id="tC" type="number" step="1" value="0"></div>
          <div><label>M</label><input id="tM" type="number" step="1" value="55"></div>
          <div><label>Y</label><input id="tY" type="number" step="1" value="85"></div>
          <div><label>K</label><input id="tK" type="number" step="1" value="0"></div>
          <div><label>O</label><input id="tO" type="number" step="1" value="0"></div>
          <div><label>G</label><input id="tG" type="number" step="1" value="0"></div>
          <div><label>V</label><input id="tV" type="number" step="1" value="0"></div>
        </div>
        <div class="row-3" style="margin-top:6px">
          <div class="swatch" id="targetSw"></div>
          <div class="tiny">Helper: CMYKOGV swatch (approx)</div>
          <div class="tiny">ICC soft proof if loaded</div>
        </div>
      </div>

      <div class="card" style="background:#0f141a">
        <h3 style="margin:0 0 6px 0;font-size:14px">Press (Measured) — LAB</h3>
        <div class="row-3">
          <div><label>L*</label><input id="pL" type="number" step="0.01" value="63.5"></div>
          <div><label>a*</label><input id="pA" type="number" step="0.01" value="15.5"></div>
          <div><label>b*</label><input id="pB" type="number" step="0.01" value="19.2"></div>
        </div>
        <div class="row" style="margin-top:6px;grid-template-columns:repeat(7,1fr)">
          <div><label>C</label><input id="pC" type="number" step="1" value="0"></div>
          <div><label>M</label><input id="pM" type="number" step="1" value="58"></div>
          <div><label>Y</label><input id="pY" type="number" step="1" value="90"></div>
          <div><label>K</label><input id="pK" type="number" step="1" value="0"></div>
          <div><label>O</label><input id="pO" type="number" step="1" value="0"></div>
          <div><label>G</label><input id="pG" type="number" step="1" value="0"></div>
          <div><label>V</label><input id="pV" type="number" step="1" value="0"></div>
        </div>
        <div class="row-3" style="margin-top:6px">
          <div class="swatch" id="pressSw"></div>
          <div class="tiny">Helper: CMYKOGV swatch (approx)</div>
          <div class="tiny">ICC soft proof if loaded</div>
        </div>
      </div>
    </div>

    <div class="flex" style="margin:10px 0">
      <button class="btn primary" id="calcBtn">Calculate ΔE & Suggestions</button>
      <button class="btn" id="swapBtn" title="Swap target & press">Swap</button>
      <span class="pill">Illuminant: <strong id="illumText">D50/2°</strong></span>
      <span class="pill">Substrate profile: <strong id="subsText">HP White</strong></span>
      <span class="pill">Profile: <strong id="iccName">(none)</strong></span>
    </div>

    <div class="kpi">
      <div class="card">
        <label>ΔE76</label><div id="de76" class="badge pass">0.00</div>
        <label style="margin-top:8px">ΔE94</label><div id="de94" class="badge pass">0.00</div>
      </div>
      <div class="card">
        <label>ΔE2000</label><div id="de00" class="badge pass" style="font-size:18px;padding:6px 10px">0.00</div>
        <div class="tiny" id="passNote">Within tolerance</div>
      </div>
      <div class="card">
        <label>Press‑Side Guidance</label>
        <div id="advice" class="tiny">—</div>
      </div>
    </div>

    <div class="card" style="margin-top:10px">
      <h3 style="margin:0 0 8px 0;font-size:14px">Suggested Ink Corrections (CMYKOGV)</h3>
      <table id="corrTable">
        <thead><tr><th>Channel</th><th>Δ</th><th>New %</th><th class="right">Note</th></tr></thead>
        <tbody></tbody>
      </table>
      <div class="tiny" style="margin-top:6px">
        Heuristic: uses ΔE00 vector, gray balance (G7‑style L*), overprint heuristics, substrate profile weights, and O/G/V distribution by hue.
      </div>
    </div>
  </section>

  <!-- Middle Column -->
  <section class="grid cols-2">
    <div class="card">
      <h2>2) Patch Grid • CSV • Heatmap • Auto‑Balance</h2>
      <div class="row-2">
        <div>
          <label>Import CSV (e.g., eXact export with L*,a*,b*)</label>
          <input id="csvFile" type="file" accept=".csv" />
        </div>
        <div>
          <label>Grid Size</label>
          <select id="gridSize">
            <option>4×6</option><option selected>6×8</option><option>10×10</option>
          </select>
        </div>
      </div>
      <div class="flex" style="margin:8px 0">
        <button class="btn" id="genGrid">Generate Grid</button>
        <button class="btn" id="clearGrid">Clear</button>
        <button class="btn" id="autoBalance">Auto‑Balance (CCM + Gray)</button>
        <span class="tiny">Click any cell to edit Target/Press LAB. ΔE00 auto‑updates.</span>
      </div>
      <div id="gridHost"></div>
      <div style="margin-top:8px">
        <canvas id="heatmap" height="220"></canvas>
        <div class="tiny" id="heatmapHint" style="margin-top:4px"></div>
      </div>
    </div>

    <div class="card">
      <h2>3) Resolve‑Style CCM (3×3) from Paired Charts</h2>
      <div class="tiny" style="margin-top:-4px;margin-bottom:6px">
        Load two charts (Target & Press) with same patch order to estimate a 3×3 color correction matrix in CIE Lab (linear regression).
      </div>
      <div class="row-2">
        <div>
          <label>Target CSV (L*,a*,b*)</label>
          <input id="ccmTarget" type="file" accept=".csv" />
        </div>
        <div>
          <label>Press CSV (L*,a*,b*)</label>
          <input id="ccmPress" type="file" accept=".csv" />
        </div>
      </div>
      <div class="flex" style="margin:8px 0">
        <button class="btn primary" id="computeCCM">Compute CCM</button>
        <button class="btn" id="applyCCM">Apply CCM → Press LAB</button>
      </div>
      <pre id="ccmOut" class="code" style="background:#0b0f14;border:1px solid var(--border);padding:10px;border-radius:10px;min-height:84px">CCM: —</pre>
      <div class="tiny">Tip: 24‑patch chart (Calibrite/Datacolor) on press & proof → generate corrective CCM. Save per stock/inkset.</div>
    </div>

    <div class="card">
      <h2>4) Pantone / Brand Library (Local)</h2>
      <div class="row-2">
        <div>
          <label>Import JSON Library</label>
          <input id="libIn" type="file" accept=".json" />
        </div>
        <div>
          <label>Export JSON</label>
          <button class="btn" id="libOut">Download</button>
        </div>
      </div>
      <div class="row-2" style="margin-top:6px">
        <div>
          <label>Search Name/Code</label>
          <input id="libQuery" placeholder="e.g., PANTONE 186 C or 'Brand Red'">
        </div>
        <div>
          <label>&nbsp;</label>
          <button class="btn" id="libFind">Find</button>
        </div>
      </div>
      <div id="libResult" class="flex" style="margin-top:8px"></div>
      <div class="tiny">Use like PantoneLIVE locally: store approved LAB per substrate/method. Import/Export to share. <strong>Loaded: 1089 Pantone Colors</strong></div>
    </div>
  </section>

  <!-- Right Column -->
  <section class="card">
    <h2>5) Utilities • ICC Soft Proof • Live Spectro Bridge • SOP • Report</h2>

    <div class="card" style="background:#0f141a;margin-bottom:8px">
      <h3 style="margin:0 0 6px 0;font-size:14px">ICC Soft Proof (RGB Matrix/TRC v2)</h3>
      <div class="tiny">Load an RGB display/printer profile to improve swatch previews. Supports ICC v2 matrix/TRC (<span class="tag">rXYZ/gXYZ/bXYZ + rTRC/gTRC/bTRC</span>). CMYK LUT profiles require CSV DeviceLink import below.</div>
      <div class="row-2" style="margin-top:6px">
        <div>
          <label>Load ICC (.icc/.icm)</label>
          <input id="iccFile" type="file" accept=".icc,.icm" />
        </div>
        <div>
          <label>CMYK→LAB DeviceLink CSV (optional)</label>
          <input id="dlFile" type="file" accept=".csv" />
        </div>
      </div>
      <div class="row-3" style="margin-top:6px">
        <div><div class="swatch" id="proofPrev"></div><div class="tiny">Proof (ICC)</div></div>
        <div><div class="swatch" id="pressPrev"></div><div class="tiny">Press (sim)</div></div>
        <div><div class="swatch" id="neutralPrev"></div><div class="tiny">Neutral ref</div></div>
      </div>
      <div class="row-3" style="margin-top:6px">
        <div><label>Dot Gain %</label><input id="dotGain" type="number" step="1" value="12"></div>
        <div><label>Paper Tint a*</label><input id="paperA" type="number" step="0.1" value="0.5"></div>
        <div><label>Paper Tint b*</label><input id="paperB" type="number" step="0.1" value="2.0"></div>
      </div>
    </div>

    <div class="card" style="background:#0f141a;margin-bottom:8px">
      <h3 style="margin:0 0 6px 0;font-size:14px">Live Spectro Bridge (Folder Watch)</h3>
      <div class="tiny">Connect a folder that receives spectro CSV exports (e.g., X‑Rite eXact). New files are auto‑ingested into the Grid. <span class="muted">Uses the File System Access API when available; otherwise, drag & drop files below.</span></div>
      <div class="flex" style="margin:8px 0">
        <button class="btn" id="connectFolder">Connect Folder</button>
        <span class="pill" id="bridgeStatus">Not connected</span>
      </div>
      <div id="dropZone" style="border:1px dashed var(--border);border-radius:12px;padding:12px;text-align:center;">
        <div class="tiny">Drag & drop CSV files here to ingest</div>
      </div>
    </div>

    <div class="card" style="background:#0f141a;margin-bottom:8px">
      <h3 style="margin:0 0 6px 0;font-size:14px">Client Profiles</h3>
      <div class="row-2">
        <div>
          <label>Select Client</label>
          <select id="clientSelect"></select>
        </div>
        <div>
          <label>&nbsp;</label>
          <button class="btn" id="clientNew">New / Edit</button>
        </div>
      </div>
      <div id="clientEditor" style="display:none;margin-top:6px">
        <div class="row-3">
          <div><label>Name</label><input id="clientName"></div>
          <div><label>ΔE Tolerance</label><input id="clientTol" type="number" step="0.1" value="2.0"></div>
          <div><label>Notes</label><input id="clientNotes"></div>
        </div>
        <div><label>SOP (one per line)</label><textarea id="clientSOP" rows="4"></textarea></div>
        <div class="flex" style="margin-top:6px">
          <button class="btn primary" id="clientSave">Save</button>
          <button class="btn" id="clientCancel">Cancel</button>
          <button class="btn" id="clientDelete">Delete</button>
        </div>
      </div>
    </div>

    <div class="card" style="background:#0f141a;margin-bottom:8px">
      <h3 style="margin:0 0 6px 0;font-size:14px">Operator SOP (Per Substrate)</h3>
      <div class="tiny">Press‑side checklist saved to this browser (localStorage). Included on PDF report.</div>
      <div id="sopHost"></div>
      <div class="flex" style="margin-top:8px">
        <button id="resetSOP" class="btn">Reset SOP</button>
        <button id="printReport" class="btn primary">Generate PDF Report</button>
      </div>
    </div>

    <div class="card" style="background:#0f141a;margin-top:8px">
      <h3 style="margin:0 0 6px 0;font-size:14px">Session History</h3>
      <table id="history">
        <thead><tr><th>Time</th><th>ΔE00</th><th>Target LAB</th><th>Press LAB</th><th>Substrate</th></tr></thead>
        <tbody></tbody>
      </table>
      <div class="flex" style="margin-top:8px">
        <button id="clearHist" class="btn">Clear History</button>
      </div>
    </div>

    <div class="card" style="background:#0f141a;margin-top:8px">
      <h3 style="margin:0 0 6px 0;font-size:14px">Pocket Converter (Nix‑style)</h3>
      <div class="row-2">
        <div>
          <label>HEX</label>
          <input id="uHEX" value="#d81b60">
        </div>
        <div>
          <label>RGB (0–255)</label>
          <input id="uRGB" value="216,27,96">
        </div>
      </div>
      <div class="row-2" style="margin-top:6px">
        <div>
          <label>CMYK (0–100)</label>
          <input id="uCMYK" value="0,85,55,0">
        </div>
        <div>
          <label>LAB</label>
          <input id="uLAB" value="56,63,16">
        </div>
      </div>
      <div class="flex" style="margin:8px 0">
        <button class="btn" id="uConvert">Convert</button>
        <span class="tiny">Approximate; use ICC for contract proofing.</span>
      </div>
    </div>

  </section>
</main>

<div id="toast"></div>

<script src="src/js/pantone-colors.js"></script>
<script>
"use strict";

/* ========= Utilities ========= */
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
const byId=id=>document.getElementById(id);
const fmt=n=>Number(n).toFixed(2);
const now=()=>new Date().toLocaleString();
const hasFS = 'showDirectoryPicker' in window;

// Debounce & performance helpers
function debounce(fn, wait){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), wait); }; }
let __heatRAF=null;

// Input sanitation
function toNum(v, def=0){ const n=parseFloat(v); return Number.isFinite(n)? n: def; }
function cleanLAB(arr){ return [ clamp(toNum(arr[0],0),0,100), clamp(toNum(arr[1],0),-128,128), clamp(toNum(arr[2],0),-128,128) ]; }
function sanitizeInputs(){
  const limits={tL:[0,100],tA:[-128,128],tB:[-128,128],tC:[0,100],tM:[0,100],tY:[0,100],tK:[0,100],tO:[0,100],tG:[0,100],tV:[0,100],
    pL:[0,100],pA:[-128,128],pB:[-128,128],pC:[0,100],pM:[0,100],pY:[0,100],pK:[0,100],pO:[0,100],pG:[0,100],pV:[0,100],
    tolerance:[0,10], dotGain:[0,40], paperA:[-5,5], paperB:[-5,10] };
  Object.entries(limits).forEach(([id,[min,max]])=>{
    const el=byId(id); if(!el) return;
    const apply=()=>{ let v=toNum(el.value,0); v=clamp(v,min,max); el.value=String(v); };
    el.addEventListener('blur',apply); apply();
  });
}

// Toast error guard
let __toastTimer; function toast(msg){ let el=byId('toast'); if(el){ el.textContent=msg; el.style.opacity='1'; clearTimeout(__toastTimer); __toastTimer=setTimeout(()=>{ el.style.opacity='0'; },3000);} }
window.addEventListener('error',e=>toast('Error: '+(e.message||'unknown')));
window.addEventListener('unhandledrejection',e=>toast('Promise: '+((e.reason&&e.reason.message)||e.reason||'unknown')));

// Safe call wrapper
function safeCall(fn, ...args){ try{ if(typeof fn==='function') return fn(...args); } catch(e){ toast(String(e&&e.message||e)); } }

/* ========= Basic Color Math ========= */
function cmykToRgb(c,m,y,k){
  c/=100;m/=100;y/=100;k/=100;
  const r=255*(1-c)*(1-k);
  const g=255*(1-m)*(1-k);
  const b=255*(1-y)*(1-k);
  return [r,g,b].map(v=>clamp(Math.round(v),0,255));
}
function cmykogvToRgb(C,M,Y,K,O,G,V){
  let [r,g,b]=cmykToRgb(C,M,Y,K);
  let R=r/255, Gc=g/255, B=b/255;
  R = clamp(R + (O/100)*0.25 + (V/100)*0.05, 0, 1);
  Gc= clamp(Gc+ (G/100)*0.25 + (O/100)*0.05, 0, 1);
  B = clamp(B + (V/100)*0.25 + (G/100)*0.05, 0, 1);
  return [Math.round(R*255), Math.round(Gc*255), Math.round(B*255)];
}
function rgbToXyz(r,g,b){
  [r,g,b]=[r,g,b].map(v=>{v/=255;return v<=0.04045? v/12.92: Math.pow((v+0.055)/1.055,2.4)});
  const x = r*0.4124564 + g*0.3575761 + b*0.1804375;
  const y = r*0.2126729 + g*0.7151522 + b*0.0721750;
  const z = r*0.0193339 + g*0.1191920 + b*0.9503041;
  return [x,y,z];
}
function xyzToLab(x,y,z,wp=[0.96422,1.00000,0.82521]){
  const fx=t=> (t>Math.pow(6/29,3))? Math.cbrt(t): (t/(3*Math.pow(6/29,2))+4/29);
  const [xr,yr,zr]=[x/wp[0], y/wp[1], z/wp[2]];
  const fxr=fx(xr), fyr=fx(yr), fzr=fx(zr);
  const L=116*fyr-16, a=500*(fxr-fyr), b=200*(fyr-fzr);
  return [L,a,b];
}
function rgbToLab(r,g,b){ const [x,y,z]=rgbToXyz(r,g,b); return xyzToLab(x,y,z); }
function hexToRgb(hex){ hex=hex.replace('#',''); if(hex.length===3) hex=[...hex].map(h=>h+h).join(''); const bigint=parseInt(hex,16); return [(bigint>>16)&255,(bigint>>8)&255,bigint&255]; }
function rgbToHex(r,g,b){ const h=v=>v.toString(16).padStart(2,'0'); return '#'+h(r)+h(g)+h(b); }
function approxLabToRgb(L,a,b){
  let r=128,g=128,bv=128, step=32; const target=[L,a,b];
  const dist=(A,B)=>Math.hypot(A[0]-B[0],A[1]-B[1],A[2]-B[2]);
  for(let i=0;i<6;i++){
    let best=[r,g,bv], bestd=1e9;
    for(let dr=-1;dr<=1;dr++) for(let dg=-1;dg<=1;dg++) for(let db=-1;db<=1;db++){
      const nr=clamp(r+dr*step,0,255), ng=clamp(g+dg*step,0,255), nb=clamp(bv+db*step,0,255);
      const lab=rgbToLab(nr,ng,nb); const d=dist(lab,target);
      if(d<bestd){best=[nr,ng,nb];bestd=d;}
    }
    [r,g,bv]=best; step=Math.max(1,Math.floor(step/2));
  }
  return [r,g,bv];
}

/* ΔE implementations */
function dE76(t,p){ return Math.hypot(t[0]-p[0], t[1]-p[1], t[2]-p[2]); }
function dE94(t,p){
  const [L1,a1,b1]=t, [L2,a2,b2]=p; const C1=Math.hypot(a1,b1), C2=Math.hypot(a2,b2);
  const dL=L1-L2, dC=C1-C2; const da=a1-a2, db=b1-b2;
  const dH=Math.sqrt(Math.max(0, da*da+db*db - dC*dC));
  const kL=1,kC=1,kH=1,K1=0.045,K2=0.015; const SL=1, SC=1+K1*C1, SH=1+K2*C1;
  return Math.sqrt(Math.pow(dL/(kL*SL),2)+Math.pow(dC/(kC*SC),2)+Math.pow(dH/(kH*SH),2));
}
function dE00(t,p){
  let [L1,a1,b1]=t, [L2,a2,b2]=p; const avgLp=(L1+L2)/2;
  const C1=Math.hypot(a1,b1), C2=Math.hypot(a2,b2); const avgC=(C1+C2)/2;
  const G=0.5*(1-Math.sqrt(Math.pow(avgC,7)/(Math.pow(avgC,7)+Math.pow(25,7))));
  const a1p=(1+G)*a1, a2p=(1+G)*a2; const C1p=Math.hypot(a1p,b1), C2p=Math.hypot(a2p,b2);
  const avgCp=(C1p+C2p)/2; const h1p=((Math.atan2(b1,a1p)*180/Math.PI)+360)%360; const h2p=((Math.atan2(b2,a2p)*180/Math.PI)+360)%360;
  const dLp=L2-L1, dCp=C2p-C1p; let dhp=h2p-h1p; if (dhp>180) dhp-=360; else if(dhp<-180) dhp+=360;
  const dHp=2*Math.sqrt(C1p*C2p)*Math.sin((dhp*Math.PI/180)/2);
  const avgHp = (Math.abs(h1p-h2p)>180)? (h1p+h2p+360)/2 : (h1p+h2p)/2;
  const T=1 - 0.17*Math.cos((avgHp-30)*Math.PI/180) + 0.24*Math.cos((2*avgHp)*Math.PI/180)
            + 0.32*Math.cos((3*avgHp+6)*Math.PI/180) - 0.20*Math.cos((4*avgHp-63)*Math.PI/180);
  const Sl=1+ (0.015*Math.pow(avgLp-50,2))/Math.sqrt(20+Math.pow(avgLp-50,2));
  const Sc=1+0.045*avgCp; const Sh=1+0.015*avgCp*T;
  const Rt= -2*Math.sqrt(Math.pow(avgCp,7)/(Math.pow(avgCp,7)+Math.pow(25,7))) *Math.sin((60*Math.exp(-Math.pow((avgHp-275)/25,2))*Math.PI/180));
  const kl=1,kc=1,kh=1;
  return Math.sqrt(Math.pow(dLp/(kl*Sl),2)+Math.pow(dCp/(kc*Sc),2)+Math.pow(dHp/(kh*Sh),2)+Rt*(dCp/(kc*Sc))*(dHp/(kh*Sh)));
}

/* Substrate factors */
const SUBSTRATES={
  hpw:{name:"Hot Press White", toneA:0.2, toneB:1.2, gain:0.10, weight:{C:0.9,M:1.0,Y:1.0,K:0.9,O:0.9,G:0.9,V:0.9}},
  inver:{name:"Invercote",      toneA:0.3, toneB:1.6, gain:0.12, weight:{C:0.95,M:1.0,Y:1.0,K:0.95,O:0.9,G:0.9,V:0.9}},
  gsm250:{name:"250 gsm",       toneA:0.1, toneB:0.8, gain:0.09, weight:{C:1.0,M:1.0,Y:1.0,K:1.0,O:1.0,G:1.0,V:1.0}},
  foil:{name:"Foil Board",      toneA:-0.5,toneB:2.8, gain:0.06, weight:{C:0.85,M:0.9,Y:0.9,K:0.8,O:0.8,G:0.8,V:0.8}}
};

/* State */
let LIB=window.pantoneColors ? window.pantoneColors.colors.map(color => ({
  code: color.name,
  name: color.name,
  L: 50, // Approximate LAB values - will need proper conversion
  a: 0,
  b: 0,
  cmyk: color.cmyk,
  substrate: "HP White"
})) : []; // library entries with full Pantone integration
let GRID=[]; // [{t:[L,a,b], p:[L,a,b], de00}]
let CCM=null; let CCM_DATA={t:[], p:[]};
let ICC=null; let DLINK=null;
let BRIDGE={handle:null, lastSeen:{}};

/* ========== UI Hooks ========== */
const inputIds=["tL","tA","tB","tC","tM","tY","tK","tO","tG","tV","pL","pA","pB","pC","pM","pY","pK","pO","pG","pV"];
const debouncedSw = debounce(updateSwatches, 50);
inputIds.forEach(id=>byId(id).addEventListener('input',debouncedSw));

byId('substrate').addEventListener('change',()=>{byId('subsText').textContent=SUBSTRATES[byId('substrate').value].name; updateProofing();});
byId('illuminant').addEventListener('change',()=>{byId('illumText').textContent=byId('illuminant').value.replace(' ','');});
byId('pantonePreset').addEventListener('change',handlePantonePresetChange);
byId('calcBtn').addEventListener('click',calcAll);
byId('swapBtn').addEventListener('click',()=>{
  const t=["tL","tA","tB","tC","tM","tY","tK","tO","tG","tV"].map(id=>byId(id).value);
  ["tL","tA","tB","tC","tM","tY","tK","tO","tG","tV"].forEach((id,i)=>byId(id).value=byId(["pL","pA","pB","pC","pM","pY","pK","pO","pG","pV"][i]).value);
  ["pL","pA","pB","pC","pM","pY","pK","pO","pG","pV"].forEach((id,i)=>byId(id).value=t[i]);
  updateSwatches();
});

byId('genGrid').addEventListener('click',genGrid);
byId('clearGrid').addEventListener('click',()=>{GRID=[]; renderGrid(); drawHeat();});
byId('csvFile').addEventListener('change',e=>loadCSVtoGrid(e.target.files[0]));
byId('computeCCM').addEventListener('click',computeCCM);
byId('applyCCM').addEventListener('click',applyCCM);
byId('libIn').addEventListener('change',e=>importLib(e.target.files[0]));
byId('libOut').addEventListener('click',exportLib);
byId('libFind').addEventListener('click',findLib);
byId('uConvert').addEventListener('click',doConvert);
byId('clearHist').addEventListener('click',()=>{localStorage.removeItem('hd_hist'); renderHist();});
byId('printReport').addEventListener('click',()=>window.print());
['dotGain','paperA','paperB'].forEach(id=>byId(id).addEventListener('input',updateProofing));
byId('iccFile').addEventListener('change',e=>loadICC(e.target.files[0]));
byId('dlFile').addEventListener('change',e=>loadDeviceLink(e.target.files[0]));
byId('autoBalance').addEventListener('click',autoBalance);
byId('connectFolder').addEventListener('click',connectFolder);
byId('resetSOP').addEventListener('click',()=>{localStorage.removeItem('hd_sop'); renderSOP();});

// Drag & Drop ingest (passive)
const dz=byId('dropZone');
if(dz){
  const prevent=e=>{ e.preventDefault(); dz.style.background='#0b0f14'; };
  const clearBG=e=>{ e.preventDefault(); dz.style.background='transparent'; if(e.type==='drop'){ const files=[...e.dataTransfer.files].filter(f=>f.name.endsWith('.csv')); files.forEach(loadCSVtoGrid); } };
  dz.addEventListener('dragenter', prevent, {passive:false});
  dz.addEventListener('dragover', prevent, {passive:false});
  dz.addEventListener('dragleave', clearBG, {passive:false});
  dz.addEventListener('drop', clearBG, {passive:false});
}

/* ========= Swatches / Proofing ========= */
function updateSwatches(){
  const tCMYKOGV=[+tC.value,+tM.value,+tY.value,+tK.value,+tO.value,+tG.value,+tV.value];
  const pCMYKOGV=[+pC.value,+pM.value,+pY.value,+pK.value,+pO.value,+pG.value,+pV.value];
  const tRGB=cmykogvToRgb(...tCMYKOGV), pRGB=cmykogvToRgb(...pCMYKOGV);
  const tRGBfinal = ICC? labToRgbICC([+tL.value,+tA.value,+tB.value]) : tRGB;
  const pRGBfinal = ICC? labToRgbICC([+pL.value,+pA.value,+pB.value]) : pRGB;
  byId('targetSw').style.background=rgbToHex(...tRGBfinal);
  byId('pressSw').style.background=rgbToHex(...pRGBfinal);
  updateProofing();
}

function updateProofing(){
  const t=[+byId('tL').value,+byId('tA').value,+byId('tB').value];
  const dg=+byId('dotGain').value/100, pa=+byId('paperA').value, pb=+byId('paperB').value;
  const subs=SUBSTRATES[byId('substrate').value];
  const proofRGB = ICC? labToRgbICC(t): approxLabToRgb(...t);
  byId('proofPrev').style.background=rgbToHex(...proofRGB);
  const pressSim=[ t[0]-dg*6, t[1]+pa+subs.toneA, t[2]+pb+subs.toneB ];
  const pressRGB = ICC? labToRgbICC(pressSim): approxLabToRgb(...pressSim);
  byId('pressPrev').style.background=rgbToHex(...pressRGB);
  const neutral = ICC? labToRgbICC([50,0,0]): approxLabToRgb(50,0,0); byId('neutralPrev').style.background=rgbToHex(...neutral);
}

/* ====== Core Calc ====== */
function calcAll(){
  let T=cleanLAB([+tL.value,+tA.value,+tB.value]);
  let P=cleanLAB([+pL.value,+pA.value,+pB.value]);
  const de00=dE00(T,P), de76=dE76(T,P), de94=dE94(T,P);
  const tol=+byId('tolerance').value;
  const badge=(v)=> v<=tol?'badge pass': (v<=tol*2? 'badge warn':'badge fail');
  byId('de00').className=badge(de00);  byId('de00').textContent=fmt(de00);
  byId('de76').className=badge(de76);  byId('de76').textContent=fmt(de76);
  byId('de94').className=badge(de94);  byId('de94').textContent=fmt(de94);
  byId('passNote').textContent = de00<=tol? 'Within tolerance':'Out of tolerance';
  suggestCorrections(T,P,de00);
  addHist(now(),de00,T,P,SUBSTRATES[byId('substrate').value].name);
}

/* Heuristic corrections: CMYKOGV mapping */
function suggestCorrections(T,P,de){
  const subs=SUBSTRATES[byId('substrate').value];
  const dL=T[0]-P[0], da=T[1]-P[1], db=T[2]-P[2];
  const hue=Math.atan2(db,da);
  const mag=Math.hypot(da,db);
  let dC = clamp(Math.round((-0.35*da -0.55*db)), -12, 12);
  let dM = clamp(Math.round((0.9*da -0.1*db)), -12, 12);
  let dY = clamp(Math.round((0.1*da +0.9*db)), -12, 12);
  let dK = clamp(Math.round((-0.8*dL)), -12, 12);
  let dO=0,dG=0,dV=0;
  const sector=((hue+Math.PI)/(2*Math.PI))*6;
  if(sector>=0&&sector<2){ dO = Math.round( 0.25*mag ); }
  if(sector>=1&&sector<3){ dY += Math.round( 0.10*mag ); }
  if(sector>=2&&sector<4){ dG = Math.round( 0.25*mag ); }
  if(sector>=4&&sector<5.5){ dV = Math.round( 0.25*mag ); }
  const w=subs.weight, damp=(1-subs.gain);
  dC=Math.round(dC*w.C*damp); dM=Math.round(dM*w.M*damp); dY=Math.round(dY*w.Y*damp); dK=Math.round(dK*w.K*damp);
  dO=Math.round(dO*w.O*damp); dG=Math.round(dG*w.G*damp); dV=Math.round(dV*w.V*damp);

  const cur=[+pC.value,+pM.value,+pY.value,+pK.value,+pO.value,+pG.value,+pV.value];
  const deltas=[dC,dM,dY,dK,dO,dG,dV];
  const next=cur.map((v,i)=>clamp(v+deltas[i],0,100));
  const rows=[['Cyan',dC,next[0]],['Magenta',dM,next[1]],['Yellow',dY,next[2]],['Black',dK,next[3]],['Orange',dO,next[4]],['Green',dG,next[5]],['Violet',dV,next[6]]];
  const tbody=byId('corrTable').querySelector('tbody'); tbody.innerHTML='';
  rows.forEach(([name,delta,newv])=>{
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${name}</td><td class="${delta===0?'':(delta>0?'ok':'danger')}">${delta>0?'+':''}${delta}</td><td>${newv}%</td><td class="right">${delta>0?'Raise ':'Lower '}${name}</td>`;
    tbody.appendChild(tr);
  });

  const tips=[];
  if (Math.abs(dL)>2) tips.push(dL>0?'Reduce K/overall density to raise L*':'Increase K/overall density to lower L*');
  if (Math.abs(da)>2) tips.push(da>0?'Shift toward magenta/orange (reduce C+Y if needed)':'Shift toward greenish (add C+Y / reduce M)');
  if (Math.abs(db)>2) tips.push(db>0?'Shift toward yellow/green':'Shift toward blue/violet (add C/V / reduce Y)');
  tips.push(`Check overprint/trapping on ${SUBSTRATES[byId('substrate').value].name}; dot gain ≈ ${(SUBSTRATES[byId('substrate').value].gain*100)|0}%`);
  byId('advice').innerHTML = tips.map(t=>'• '+t).join('<br>');
}

/* ====== Grid / Heatmap ====== */
function genGrid(){
  const sz=byId('gridSize').value.split('×').map(n=>+n);
  const [R,C]=sz; GRID=[];
  for(let r=0;r<R;r++){ const row=[]; for(let c=0;c<C;c++){ const t=[65,10,10], p=[65,10,10]; row.push({t,p,de00:0}); } GRID.push(row);} renderGrid(); drawHeat();
}
function renderGrid(){
  const host=byId('gridHost'); host.innerHTML='';
  if(GRID.length===0){ host.innerHTML='<div class="tiny">No grid — click "Generate Grid".</div>'; return; }
  const table=document.createElement('table');
  const thead=document.createElement('thead'); thead.innerHTML='<tr><th>Cell</th><th>Target L a b</th><th>Press L a b</th><th>ΔE00</th></tr>'; table.appendChild(thead);
  const tb=document.createElement('tbody');
  GRID.forEach((row,ri)=>{ row.forEach((cell,ci)=>{ const tr=document.createElement('tr'); const cls = cell.de00<=+tolerance.value?'ok':(cell.de00<=+tolerance.value*2?'warn':'danger');
    tr.innerHTML=`<td>R${ri+1}C${ci+1}</td>
      <td class="code"><span contenteditable data-rc="${ri},${ci},t">${cell.t.map(v=>fmt(v)).join(', ')}</span></td>
      <td class="code"><span contenteditable data-rc="${ri},${ci},p">${cell.p.map(v=>fmt(v)).join(', ')}</span></td>
      <td class="${cls}">${fmt(cell.de00||0)}</td>`; tb.appendChild(tr); }); });
  table.appendChild(tb); host.appendChild(table);
  host.querySelectorAll('[contenteditable]').forEach(el=>{
    el.addEventListener('blur',()=>{
      const [r,c,which]=el.getAttribute('data-rc').split(',');
      const nums=el.textContent.split(',').map(s=>+s.trim()).slice(0,3);
      if(nums.length===3 && nums.every(n=>!isNaN(n))){
        const clean=cleanLAB(nums); GRID[r][c][which]=clean; GRID[r][c].de00=dE00(GRID[r][c].t, GRID[r][c].p); renderGrid(); drawHeat();
      }
    });
  });
}
window.addEventListener('resize',()=>{ drawHeat(); });

let __heatmapInit=false;
function drawHeat(){
  if(__heatRAF) cancelAnimationFrame(__heatRAF);
  __heatRAF=requestAnimationFrame(()=>{
    const can=byId('heatmap'); const g=can.getContext('2d');
    const dpr=window.devicePixelRatio||1; const cssW=can.clientWidth||can.width; const cssH=can.clientHeight||can.height;
    const w=Math.max(1,Math.round(cssW*dpr)), h=Math.max(1,Math.round(cssH*dpr));
    if(can.width!==w || can.height!==h){ can.width=w; can.height=h; }
    g.setTransform(dpr,0,0,dpr,0,0); g.clearRect(0,0,cssW,cssH);
    if(GRID.length===0) return;
    const R=GRID.length, C=GRID[0].length; const cw=cssW/C, ch=cssH/R; let max=0; GRID.flat().forEach(c=>{ if(Number.isFinite(c.de00) && c.de00>max) max=c.de00; });
    GRID.forEach((row,ri)=>{ row.forEach((cell,ci)=>{ const x=ci*cw, y=ri*ch; const v=max? (Number.isFinite(cell.de00)? cell.de00/max:0):0; const shade=Math.round(40+v*160); g.fillStyle=`rgb(${shade},40,40)`;
      g.fillRect(x,y,cw-1,ch-1); g.fillStyle='rgba(255,255,255,.9)'; g.font='12px system-ui'; g.fillText(fmt(cell.de00||0), x+6,y+14); }); });
    if(!__heatmapInit){
      const hint=byId('heatmapHint');
      if(hint){ hint.textContent = hasFS ? 'Heatmap is DPI‑scaled for crispness. Folder bridge is available.' : 'Tip: Your browser does not support folder watching. Use the drag & drop zone to ingest spectro CSVs.'; }
      __heatmapInit=true;
    }
    safeCall(updateGridStats);
  });
}

/* ====== CSV Loaders (Streaming + Robust small) ====== */
async function loadCSVtoGridStream(file){
  try{
    const chunk=1024*1024; let offset=0; let leftover=''; let Lidx=-1,Aidx=-1,Bidx=-1; const T=[], P=[]; let rowIdx=0; const td=new TextDecoder();
    while(offset<file.size){
      const slice=file.slice(offset, Math.min(file.size, offset+chunk));
      const buf=await slice.arrayBuffer();
      const txt=td.decode(buf,{stream:true});
      offset+=chunk;
      const data=leftover+txt;
      const lines=data.split(/\r?\n/); leftover=lines.pop()||'';
      for(const line of lines){
        const cols=line.split(/,|;|\t/); if(!cols.length) continue;
        if(Lidx<0){
          const header=cols.map(h=>String(h).trim().toLowerCase());
          Lidx=header.findIndex(h=>/^l\*?$/.test(h)); Aidx=header.findIndex(h=>/^a\*?$/.test(h)); Bidx=header.findIndex(h=>/^b\*?$/.test(h));
          continue;
        }
        const L=+cols[Lidx], a=+cols[Aidx], b=+cols[Bidx];
        if([L,a,b].every(n=>Number.isFinite(n))){ if(rowIdx%2===0) T.push([L,a,b]); else P.push([L,a,b]); rowIdx++; }
      }
    }
    if(leftover && Lidx>=0){
      const cols=leftover.split(/,|;|\t/); const L=+cols[Lidx], a=+cols[Aidx], b=+cols[Bidx];
      if([L,a,b].every(n=>Number.isFinite(n))){ if(rowIdx%2===0) T.push([L,a,b]); else P.push([L,a,b]); }
    }
    buildGridFromPairedData(T,P);
  }catch(e){ toast('Stream parse failed; falling back'); robustLoadCSV(file); }
}
function robustLoadCSV(file){
  const reader=new FileReader();
  reader.onload=()=>{
    try{
      const lines=String(reader.result).split(/\r?\n/).filter(Boolean);
      if(lines.length<2){ toast('CSV empty'); return; }
      const header=lines[0].split(/,|;|\t/).map(h=>String(h).trim().toLowerCase());
      const Lidx=header.findIndex(h=>/^l\*?$/.test(h));
      const Aidx=header.findIndex(h=>/^a\*?$/.test(h));
      const Bidx=header.findIndex(h=>/^b\*?$/.test(h));
      if(Lidx<0||Aidx<0||Bidx<0){ toast('CSV needs L,a,b headers'); return; }
      const data=[];
      for(let i=1;i<lines.length;i++){
        const cols=lines[i].split(/,|;|\t/);
        const L=+cols[Lidx], a=+cols[Aidx], b=+cols[Bidx];
        if(Number.isFinite(L)&&Number.isFinite(a)&&Number.isFinite(b)) data.push([L,a,b]);
      }
      const half=Math.floor(data.length/2); const target=data.slice(0,half), press=data.slice(half,half*2);
      buildGridFromPairedData(target,press);
    }catch(e){ toast('CSV parse error'); }
  };
  reader.readAsText(file);
}
function buildGridFromPairedData(target, press, cap=400){
  const half=Math.min(target.length, press.length);
  if(half===0){ toast('No usable LAB rows found.'); return; }
  const step=Math.max(1, Math.floor(half/Math.min(cap, half)));
  const Tsel=[], Psel=[];
  for(let i=0;i<half;i+=step){ Tsel.push(target[i]); Psel.push(press[i]); }
  const n=Tsel.length; const size=Math.ceil(Math.sqrt(n)); GRID=[]; let k=0;
  for(let r=0;r<size;r++){
    const row=[];
    for(let c=0;c<size;c++){
      if(k<n){ const t=Tsel[k], p=Psel[k]||Tsel[k]; row.push({t,p,de00:dE00(t,p)}); }
      k++;
    }
    if(row.length) GRID.push(row);
  }
  renderGrid(); drawHeat(); safeCall(updateGridStats); toast(`Loaded ${half} pairs (displaying ${n})`);
}
function loadCSVtoGrid(file){ if(file && file.size>5*1024*1024){ return loadCSVtoGridStream(file); } return robustLoadCSV(file); }

/* ====== CCM (Least Squares) ====== */
function solveLeastSquares(A,B){
  function transpose(M){ return M[0].map((_,i)=>M.map(r=>r[i])); }
  function mult(X,Y){ const out=new Array(X.length).fill(null).map(()=>new Array(Y[0].length).fill(0)); for(let i=0;i<X.length;i++) for(let j=0;j<Y[0].length;j++) for(let k=0;k<Y.length;k++) out[i][j]+=X[i][k]*Y[k][j]; return out; }
  function inv3(M){ const [a,b,c,d,e,f,g,h,i]=[M[0][0],M[0][1],M[0][2],M[1][0],M[1][1],M[1][2],M[2][0],M[2][1],M[2][2]]; const A=e*i-f*h,B=-(d*i-f*g),C=d*h-e*g,D=-(b*i-c*h),E=a*i-c*g,F=-(a*h-b*g),G=b*f-c*e,H=-(a*f-b*d),I=a*e-b*d; const det=a*A + b*B + c*C; if(Math.abs(det)<1e-9) return null; const inv=[[A/det,D/det,G/det],[B/det,E/det,H/det],[C/det,F/det,I/det]]; return inv; }
  const At=transpose(A); const AtA=mult(At,A), AtB=mult(At,B); const AtAinv=inv3(AtA); if(!AtAinv) return null; return mult(AtAinv,AtB);
}
function computeCCM(){
  const tF=byId('ccmTarget').files[0], pF=byId('ccmPress').files[0]; if(!tF || !pF){ alert('Load both Target and Press CSVs'); return; }
  const read=(f)=>new Promise(res=>{
    const r=new FileReader(); r.onload=()=>{
      const rows=r.result.split(/\r?\n/).filter(Boolean).map(r=>r.split(/,|;|\t/));
      const header=rows[0].map(h=>h.trim().toLowerCase());
      const L=header.findIndex(h=>/^l\*?$/.test(h));
      const A=header.findIndex(h=>/^a\*?$/.test(h));
      const B=header.findIndex(h=>/^b\*?$/.test(h));
      const data=rows.slice(1).map(r=>[+r[L],+r[A],+r[B]]).filter(v=>v.every(n=>!isNaN(n)));
      res(data);
    }; r.readAsText(f);
  });
  Promise.all([read(tF),read(pF)]).then(([T,P])=>{
    const n=Math.min(T.length,P.length); if(n<3){ byId('ccmOut').textContent='CCM: Need ≥3 patches'; CCM=null; return; }
    const A=P.slice(0,n); const B=T.slice(0,n); const X=solveLeastSquares(A,B);
    if(!X){ byId('ccmOut').textContent='CCM: Singular matrix — need more diverse patches'; CCM=null; return; }
    CCM=X; CCM_DATA={t:T.slice(0,n),p:P.slice(0,n)};
    byId('ccmOut').textContent='CCM:\n' + X.map(r=>'[ '+r.map(v=>v.toFixed(6)).join(' , ')+' ]').join('\n');
  });
}
function applyCCM(){
  if(!CCM){ alert('Compute CCM first'); return; }
  const p=[+pL.value,+pA.value,+pB.value];
  const out=[ CCM[0][0]*p[0]+CCM[0][1]*p[1]+CCM[0][2]*p[2],
              CCM[1][0]*p[0]+CCM[1][1]*p[1]+CCM[1][2]*p[2],
              CCM[2][0]*p[0]+CCM[2][1]*p[1]+CCM[2][2]*p[2] ];
  [pL,pA,pB].forEach((el,i)=>el.value=out[i].toFixed(2));
  calcAll();
}

/* ====== Auto‑Balance (CCM + Gray axis) ====== */
function autoBalance(){
  if(GRID.length===0){ alert('Generate or import a grid first.'); return; }
  const T=[], P=[]; GRID.flat().forEach(cell=>{T.push(cell.t); P.push(cell.p);});
  const X=solveLeastSquares(P,T); if(!X){ alert('CCM failed — need more varied patches.'); return; }
  const P2=P.map(v=>[ X[0][0]*v[0]+X[0][1]*v[1]+X[0][2]*v[2], X[1][0]*v[0]+X[1][1]*v[1]+X[1][2]*v[2], X[2][0]*v[0]+X[2][1]*v[1]+X[2][2]*v[2] ]);
  const median=(arr)=>{const s=[...arr].sort((a,b)=>a-b); const m=Math.floor(s.length/2); return s.length%2?s[m]:(s[m-1]+s[m])/2; };
  const aErr=T.map((v,i)=>v[1]-P2[i][1]); const bErr=T.map((v,i)=>v[2]-P2[i][2]); const aMed=median(aErr), bMed=median(bErr);
  const P3=P2.map(v=>[v[0], v[1]+aMed*0.5, v[2]+bMed*0.5]);
  let idx=0; for(let r=0;r<GRID.length;r++){ for(let c=0;c<GRID[0].length;c++){ GRID[r][c].p=P3[idx++]; GRID[r][c].de00=dE00(GRID[r][c].t, GRID[r][c].p); }}
  renderGrid(); drawHeat();
  byId('ccmOut').textContent='Auto‑Balance applied (CCM + gray bias). Review ΔE heatmap.';
}

/* ====== Pantone Preset Functionality ====== */
function handlePantonePresetChange(){
  const select = byId('pantonePreset');
  const selectedValue = select.value;
  
  if(!selectedValue) return;
  
  // Find the selected Pantone color
  let selectedColor = null;
  if(window.pantoneColors && window.pantoneColors.colors) {
    selectedColor = window.pantoneColors.colors.find(color => color.name === selectedValue);
  }
  
  if(selectedColor && selectedColor.cmyk) {
    // Set CMYK values from selected Pantone color
    byId('tC').value = selectedColor.cmyk.c || 0;
    byId('tM').value = selectedColor.cmyk.m || 0;
    byId('tY').value = selectedColor.cmyk.y || 0;
    byId('tK').value = selectedColor.cmyk.k || 0;
    
    // Convert CMYK to approximate LAB for display
    const rgb = cmykToRgb(selectedColor.cmyk.c || 0, selectedColor.cmyk.m || 0, selectedColor.cmyk.y || 0, selectedColor.cmyk.k || 0);
    const lab = rgbToLab(...rgb);
    byId('tL').value = fmt(lab[0]);
    byId('tA').value = fmt(lab[1]);
    byId('tB').value = fmt(lab[2]);
    
    // Update swatches
    updateSwatches();
    
    // Show toast notification
    toast(`Applied ${selectedColor.name} - CMYK: ${selectedColor.cmyk.c},${selectedColor.cmyk.m},${selectedColor.cmyk.y},${selectedColor.cmyk.k}`);
  }
}

function populatePantonePresets(){
  const select = byId('pantonePreset');
  if(!select) return;
  
  // Clear existing options except the first one
  select.innerHTML = '<option value="">Select Pantone Color...</option>';
  
  if(window.pantoneColors && window.pantoneColors.colors) {
    // Group popular Pantone colors for easy access
    const popularColors = [
      'PANTONE 186 PC', 'PANTONE 300 PC', 'PANTONE 485 PC', 'PANTONE 286 PC',
      'PANTONE 116 PC', 'PANTONE 355 PC', 'PANTONE 264 PC', 'PANTONE 485 PC',
      'PANTONE Black PC', 'PANTONE Pro. Cyan PC', 'PANTONE Pro. Mag. PC', 'PANTONE Pro. Yel. PC'
    ];
    
    // Add popular colors first
    const popularGroup = document.createElement('optgroup');
    popularGroup.label = 'Popular Pantone Colors';
    
    popularColors.forEach(colorName => {
      const color = window.pantoneColors.colors.find(c => c.name === colorName);
      if(color) {
        const option = document.createElement('option');
        option.value = color.name;
        option.textContent = `${color.name} (C${color.cmyk.c} M${color.cmyk.m} Y${color.cmyk.y} K${color.cmyk.k})`;
        popularGroup.appendChild(option);
      }
    });
    
    select.appendChild(popularGroup);
    
    // Add all colors grouped by series
    const allGroup = document.createElement('optgroup');
    allGroup.label = 'All Pantone Colors';
    
    // Sort colors by name for better organization
    const sortedColors = [...window.pantoneColors.colors]
      .filter(color => !popularColors.includes(color.name))
      .sort((a, b) => a.name.localeCompare(b.name))
      .slice(0, 200); // Limit to first 200 to avoid performance issues
    
    sortedColors.forEach(color => {
      const option = document.createElement('option');
      option.value = color.name;
      option.textContent = `${color.name} (C${color.cmyk.c} M${color.cmyk.m} Y${color.cmyk.y} K${color.cmyk.k})`;
      allGroup.appendChild(option);
    });
    
    select.appendChild(allGroup);
  }
}

/* ====== Library ====== */
function importLib(file){ const r=new FileReader(); r.onload=()=>{ try{ LIB=JSON.parse(r.result); renderLib({msg:'Loaded '+LIB.length+' entries'}); } catch(e){ alert('Invalid JSON'); } }; r.readAsText(file); }
function exportLib(){ const blob=new Blob([JSON.stringify(LIB,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='hdcmyk_library.json'; a.click(); }
function findLib(){ 
  const q=byId('libQuery').value.trim().toLowerCase(); 
  let res = LIB.filter(it=> (it.name||'').toLowerCase().includes(q) || (it.code||'').toLowerCase().includes(q));
  
  // If no results and we have the global Pantone data, search there
  if(res.length === 0 && window.pantoneColors && window.pantoneColors.searchPantoneColors) {
    const pantoneResults = window.pantoneColors.searchPantoneColors(q);
    res = pantoneResults.slice(0, 50).map(color => ({
      code: color.name,
      name: color.name,
      L: 50, // Approximate - would need proper CMYK to LAB conversion
      a: 0,
      b: 0,
      cmyk: color.cmyk,
      substrate: "HP White"
    }));
  }
  renderLib({items:res}); 
}
function renderLib({items=[],msg=''}={}){ const box=byId('libResult'); box.innerHTML=''; if(msg) box.innerHTML=`<div class="tiny">${msg}</div>`; items.slice(0,50).forEach(it=>{
  const sw=document.createElement('div'); sw.className='pill'; sw.style.cursor='pointer'; 
  
  let rgb;
  if(it.cmyk) {
    // Convert CMYK to RGB for display
    rgb = cmykToRgb(it.cmyk.c || 0, it.cmyk.m || 0, it.cmyk.y || 0, it.cmyk.k || 0);
  } else {
    rgb = approxLabToRgb(it.L,it.a,it.b);
  }
  
  sw.innerHTML=`<span class="swatch" style="width:26px;height:26px;border-radius:6px;background:${rgbToHex(...rgb)}"></span>
    <strong>${it.code||it.name}</strong> <span class="tiny">${it.cmyk ? `CMYK ${it.cmyk.c},${it.cmyk.m},${it.cmyk.y},${it.cmyk.k}` : `LAB ${fmt(it.L)},${fmt(it.a)},${fmt(it.b)}`} • ${it.substrate||'—'}</span>`;
  sw.onclick=()=>{ 
    if(it.cmyk) {
      // Set CMYK values
      byId('tC').value = it.cmyk.c || 0;
      byId('tM').value = it.cmyk.m || 0;
      byId('tY').value = it.cmyk.y || 0;
      byId('tK').value = it.cmyk.k || 0;
      // Convert to approximate LAB for display
      const labApprox = rgbToLab(...cmykToRgb(it.cmyk.c || 0, it.cmyk.m || 0, it.cmyk.y || 0, it.cmyk.k || 0));
      byId('tL').value = fmt(labApprox[0]);
      byId('tA').value = fmt(labApprox[1]);
      byId('tB').value = fmt(labApprox[2]);
    } else {
      byId('tL').value=it.L; byId('tA').value=it.a; byId('tB').value=it.b;
    }
    updateSwatches(); 
  };
  box.appendChild(sw);
}); }

/* ====== Pocket Converter ====== */
function doConvert(){ try{
  const hex=byId('uHEX').value.trim(); const rgbStr=byId('uRGB').value.trim();
  let rgb = hex? hexToRgb(hex) : rgbStr.split(',').map(n=>+n.trim());
  const lab=rgbToLab(...rgb);
  const k=1-(Math.max(...rgb)/255);
  const C=(1-rgb[0]/255-k)/(1-k)||0, M=(1-rgb[1]/255-k)/(1-k)||0, Y=(1-rgb[2]/255-k)/(1-k)||0;
  byId('uLAB').value=`${fmt(lab[0])},${fmt(lab[1])},${fmt(lab[2])}`;
  byId('uCMYK').value=[C,M,Y,k].map(v=>clamp(Math.round(v*100),0,100)).join(',');
}catch(e){ alert('Could not convert'); }}

/* ====== History ====== */
function addHist(time,de,T,P,subs){ const rec={time,de:fmt(de),T:P3(T),P:P3(P),subs}; const h=JSON.parse(localStorage.getItem('hd_hist')||'[]'); h.unshift(rec); localStorage.setItem('hd_hist',JSON.stringify(h.slice(0,200))); renderHist(); function P3(v){return v.map(n=>+fmt(n))} }
function renderHist(){ const tb=byId('history').querySelector('tbody'); tb.innerHTML=''; const h=JSON.parse(localStorage.getItem('hd_hist')||'[]'); h.forEach(r=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td>${r.time}</td><td>${r.de}</td><td class="code">${r.T.join(', ')}</td><td class="code">${r.P.join(', ')}</td><td>${r.subs}</td>`; tb.appendChild(tr); }); }

/* ====== ICC Loader (RGB Matrix/TRC) ====== */
function loadICC(file){ const r=new FileReader(); r.onload=()=>{ try{ ICC=parseICC(new DataView(r.result)); byId('iccName').textContent=file.name; updateSwatches(); } catch(e){ ICC=null; byId('iccName').textContent='(failed)'; alert('Could not parse ICC. Only matrix/TRC v2 RGB profiles supported.'); } }; r.readAsArrayBuffer(file); }
function parseICC(dv){
  function getString(off,len){ let s=''; for(let i=0;i<len;i++){ const c=dv.getUint8(off+i); if(c===0) break; s+=String.fromCharCode(c);} return s; }
  const sig=getString(36,4); if(sig!=='acsp') throw new Error('Not ICC');
  const tagCount=dv.getUint32(128); const tags={}; for(let i=0;i<tagCount;i++){ const base=128+4 + i*12; const sig=getString(base,4); const off=dv.getUint32(base+4); const len=dv.getUint32(base+8); tags[sig]={off,len}; }
  function readXYZ(tag){ const o=tags[tag].off+8; function s15f16(x){ return dv.getInt32(o+x)/65536; } return [s15f16(0), s15f16(4), s15f16(8)]; }
  function readTRC(tag){ const o=tags[tag].off; const type=getString(o,4); if(type==='curv'){ const n=dv.getUint32(o+8); if(n===1){ const gamma=dv.getUint16(o+12)/256; return {type:'gamma',gamma}; } else { const arr=[]; for(let i=0;i<n;i++){ arr.push(dv.getUint16(o+12+2*i)/65535); } return {type:'lut',table:arr}; } } else { return {type:'gamma',gamma:2.2}; } }
  const rXYZ=tags['rXYZ']?readXYZ('rXYZ'):[0.9642,0,0]; const gXYZ=tags['gXYZ']?readXYZ('gXYZ'):[0,1,0]; const bXYZ=tags['bXYZ']?readXYZ('bXYZ'):[0,0,0.8249];
  const rTRC=tags['rTRC']?readTRC('rTRC'):{type:'gamma',gamma:2.2}; const gTRC=tags['gTRC']?readTRC('gTRC'):{type:'gamma',gamma:2.2}; const bTRC=tags['bTRC']?readTRC('bTRC'):{type:'gamma',gamma:2.2};
  const M=[[rXYZ[0],gXYZ[0],bXYZ[0]],[rXYZ[1],gXYZ[1],bXYZ[1]],[rXYZ[2],gXYZ[2],bXYZ[2]]];
  function inv3(M){ const [a,b,c,d,e,f,g,h,i]=[M[0][0],M[0][1],M[0][2],M[1][0],M[1][1],M[1][2],M[2][0],M[2][1],M[2][2]]; const A=e*i-f*h,B=-(d*i-f*g),C=d*h-e*g,D=-(b*i-c*h),E=a*i-c*g,F=-(a*h-b*g),G=b*f-c*e,H=-(a*f-b*d),I=a*e-b*d; const det=a*A + b*B + c*C; if(Math.abs(det)<1e-9) return null; const inv=[[A/det,D/det,G/det],[B/det,E/det,H/det],[C/det,F/det,I/det]]; return inv; }
  const Minv=inv3(M); if(!Minv) throw new Error('Bad ICC matrix');
  function gammaEncode(v,trc){ if(trc.type==='gamma') return Math.pow(v,1/trc.gamma); if(trc.type==='lut'){ const idx=Math.round(v*(trc.table.length-1)); return trc.table[clamp(idx,0,trc.table.length-1)]; } return v; }
  return { M, Minv, rTRC, gTRC, bTRC, gammaEncode };
}
function labToRgbICC(Lab){
  if(!ICC){ return approxLabToRgb(...Lab); }
  const [L,a,b]=Lab;
  const fy=(L+16)/116; const fx= a/500 + fy; const fz= fy - b/200;
  function finv(t){ return (t>6/29)? Math.pow(t,3): (t-4/29)/7.787; }
  const Xn=0.96422, Yn=1.00000, Zn=0.82521;
  const X=Xn*finv(fx), Y=Yn*finv(fy), Z=Zn*finv(fz);
  const linR = ICC.Minv[0][0]*X + ICC.Minv[0][1]*Y + ICC.Minv[0][2]*Z;
  const linG = ICC.Minv[1][0]*X + ICC.Minv[1][1]*Y + ICC.Minv[1][2]*Z;
  const linB = ICC.Minv[2][0]*X + ICC.Minv[2][1]*Y + ICC.Minv[2][2]*Z;
  const R = clamp(Math.round(ICC.gammaEncode(clamp(linR,0,1),ICC.rTRC)*255),0,255);
  const G = clamp(Math.round(ICC.gammaEncode(clamp(linG,0,1),ICC.gTRC)*255),0,255);
  const B = clamp(Math.round(ICC.gammaEncode(clamp(linB,0,1),ICC.bTRC)*255),0,255);
  return [R,G,B];
}

/* ====== DeviceLink CSV (CMYK→LAB LUT) ====== */
function loadDeviceLink(file){ const r=new FileReader(); r.onload=()=>{ try{ DLINK=parseDeviceLink(r.result); alert('DeviceLink loaded: '+Object.keys(DLINK).length+' entries'); } catch(e){ alert('DeviceLink parse failed'); } }; r.readAsText(file); }
function parseDeviceLink(text){
  const rows=text.split(/\r?\n/).filter(Boolean).map(r=>r.split(/,|;|\t/).map(x=>x.trim()));
  const head=rows[0].map(h=>h.toLowerCase()); const idx={C:head.indexOf('c'),M:head.indexOf('m'),Y:head.indexOf('y'),K:head.indexOf('k'),L:head.indexOf('l'),A:head.indexOf('a'),B:head.indexOf('b')};
  if(Object.values(idx).some(v=>v<0)) throw new Error('bad header');
  const map={}; for(let i=1;i<rows.length;i++){ const r=rows[i]; const key=[r[idx.C],r[idx.M],r[idx.Y],r[idx.K]].map(v=>Math.round(+v)).join('-'); map[key]=[+r[idx.L],+r[idx.A],+r[idx.B]]; }
  return map;
}
function cmykToLabViaDL(C,M,Y,K){ if(!DLINK) return null; const key=[C,M,Y,K].map(v=>Math.round(v)).join('-'); return DLINK[key]||null; }

/* ====== Live Spectro Bridge ====== */
async function connectFolder(){
  if(!hasFS){ byId('bridgeStatus').textContent='Not supported (use Chrome/Edge) or drag & drop below.'; byId('bridgeStatus').className='pill'; return; }
  try{
    const handle = await window.showDirectoryPicker();
    BRIDGE.handle=handle; byId('bridgeStatus').textContent='Connected'; byId('bridgeStatus').className='pill';
    pollFolder();
  } catch(e){ byId('bridgeStatus').textContent='Permission denied or canceled'; byId('bridgeStatus').className='pill'; }
}
async function pollFolder(){
  if(!BRIDGE.handle) return;
  for await (const [name,handle] of BRIDGE.handle.entries()){
    if(name.toLowerCase().endsWith('.csv')){
      const f=await handle.getFile(); const last=f.lastModified;
      if(BRIDGE.lastSeen[name] && BRIDGE.lastSeen[name]===last) continue;
      BRIDGE.lastSeen[name]=last;
      const text=await f.text();
      try{ const blob=new Blob([text],{type:'text/csv'}); loadCSVtoGrid(new File([blob], name, {type:'text/csv'})); }catch(e){}
    }
  }
  setTimeout(pollFolder, 2000);
}

/* ====== SOP ====== */
const DEFAULT_SOP={
  hpw:[
    'Verify plate curve / cutback curve ID',
    'Check trapping & overprint in Illustrator (company standard)',
    'Ink limits OK; densities within spec',
    'Color bar + registration tree placed',
    'Ink eaters & takeoff bars per color present',
    'Substrate: Hot Press White confirmed',
    'Proof EPL aligned',
    '10 random patches within ΔE00 tolerance',
    'Customer/QA sign-off recorded'
  ],
  inver:[
    'Verify plate curve / cutback curve ID',
    'Trapping & overprint checked',
    'Ink limits OK; densities within spec',
    'Color bar + registration tree placed',
    'Ink eaters & takeoff bars per color present',
    'Substrate: Invercote confirmed',
    'EPL / proof profile aligned',
    'ΔE00 within tolerance (record)',
    'Sign-off recorded'
  ],
  gsm250:[
    'Curve ID verified',
    'Overprint preview matches',
    'Ink limits & densities OK',
    'Color bar present',
    'Takeoff bars per channel',
    'Substrate: 250 gsm confirmed',
    'Proof/press alignment check',
    'ΔE00 audit',
    'Sign-off'
  ],
  foil:[
    'Curve ID verified',
    'White underprint where needed',
    'Overprint & trapping correct',
    'Ink limits adjusted for Foil Board',
    'Color bar + reg marks present',
    'Substrate: Foil Board confirmed',
    'Proof EPL aligned',
    'ΔE00 audit incl. metallic areas',
    'Sign-off'
  ]
};
function renderSOP(){
  const host=byId('sopHost'); host.innerHTML=''; const key=byId('substrate').value;
  const saved=JSON.parse(localStorage.getItem('hd_sop')||'{}');
  const items=(saved[key]||DEFAULT_SOP[key]);
  items.forEach((text,i)=>{
    const id='sop_'+i; const row=document.createElement('div'); row.className='flex';
    row.innerHTML=`<input type="checkbox" id="${id}"><label for="${id}" style="margin:0 0 0 8px">${text}</label>`;
    const cb=row.querySelector('input');
    cb.checked = saved[key]? !!saved[key+'_checked_'+i] : false;
    cb.addEventListener('change',()=>{ const cur=JSON.parse(localStorage.getItem('hd_sop')||'{}'); cur[key]=items; cur[key+'_checked_'+i]=cb.checked; localStorage.setItem('hd_sop',JSON.stringify(cur)); });
    host.appendChild(row);
  });
}

/* ====== KPIs (Median / 95th / Max) ====== */
function ensureGridStats(){
  const heat=byId('heatmap'); if(!heat||!heat.parentElement) return;
  if(byId('gridStats')) return;
  const stats=document.createElement('div'); stats.id='gridStats'; stats.className='kpi'; stats.style.marginTop='8px';
  stats.innerHTML=`<div class="card"><div class="tiny">Median ΔE00</div><div id="statMedian" class="badge">—</div></div>
                   <div class="card"><div class="tiny">95th ΔE00</div><div id="statP95" class="badge">—</div></div>
                   <div class="card"><div class="tiny">Max ΔE00</div><div id="statMax" class="badge">—</div></div>`;
  heat.parentElement.appendChild(stats);
}
function updateGridStats(){
  ensureGridStats();
  const vals = GRID.flat().map(c=>c.de00||0).filter(v=>Number.isFinite(v));
  const tol = (byId('tolerance')? toNum(byId('tolerance').value,2):2);
  const stat=(arr,q)=>{ if(arr.length===0) return NaN; const s=[...arr].sort((a,b)=>a-b); const i=Math.round(q*(s.length-1)); return s[Math.max(0,Math.min(s.length-1,i))]; };
  const median=stat(vals,0.5), p95=stat(vals,0.95), max=vals.length? Math.max(...vals):NaN;
  function paint(id,v){ const el=byId(id); if(!el) return; if(!isFinite(v)){ el.textContent='—'; el.className='badge'; return; } el.textContent=fmt(v); el.className = v<=tol? 'badge pass' : (v<=tol*2? 'badge warn':'badge fail'); }
  paint('statMedian', median); paint('statP95', p95); paint('statMax', max);
}
if(byId('tolerance')) byId('tolerance').addEventListener('input', debounce(()=>{ safeCall(updateGridStats); }, 80));

/* ====== Client Profiles ====== */
let CLIENTS={};
function saveClients(){ localStorage.setItem('hd_clients', JSON.stringify(CLIENTS)); }
function applyClient(name){
  const c=CLIENTS[name]; if(!c) return;
  localStorage.setItem('hd_current_client', name);
  if(Number.isFinite(c.tolerance) && byId('tolerance')) byId('tolerance').value=String(c.tolerance);
  if(Array.isArray(c.sop) && c.sop.length){ const key=byId('substrate').value; const cur=JSON.parse(localStorage.getItem('hd_sop')||'{}'); cur[key]=c.sop; localStorage.setItem('hd_sop', JSON.stringify(cur)); renderSOP(); }
  safeCall(updateGridStats);
}
function loadClients(){
  let saved={}; try{ saved=JSON.parse(localStorage.getItem('hd_clients')||'{}')||{}; }catch(_){ saved={}; }
  CLIENTS = (saved && typeof saved==='object')? saved: {};
  if(Object.keys(CLIENTS).length===0){ CLIENTS={ 'Default': { tolerance:2.0, notes:'General default', sop:[] } }; saveClients(); }
  const sel=byId('clientSelect'); if(sel){
    sel.innerHTML=''; Object.keys(CLIENTS).forEach(name=>{ const opt=document.createElement('option'); opt.value=name; opt.textContent=name; sel.appendChild(opt); });
    const cur=localStorage.getItem('hd_current_client')||Object.keys(CLIENTS)[0]; sel.value=cur; applyClient(cur);
    sel.onchange=(e)=>applyClient(e.target.value);
  }
}
byId('clientNew').addEventListener('click',()=>{
  const sel=byId('clientSelect'); const cur=sel.value;
  const c=CLIENTS[cur]||{tolerance:2.0,notes:'',sop:[]};
  byId('clientName').value=cur||'';
  byId('clientTol').value=c.tolerance||2.0;
  byId('clientNotes').value=c.notes||'';
  byId('clientSOP').value=(c.sop||[]).join('\n');
  const ed=byId('clientEditor'); ed.style.display = ed.style.display==='none'?'block':'none';
});
byId('clientSave').addEventListener('click',()=>{
  const name=(byId('clientName').value.trim()||'Untitled');
  CLIENTS[name]={ tolerance: toNum(byId('clientTol').value,2), notes: byId('clientNotes').value.trim(), sop: byId('clientSOP').value.split(/\r?\n/).map(s=>s.trim()).filter(Boolean) };
  saveClients(); loadClients(); applyClient(name); byId('clientEditor').style.display='none'; toast('Client saved.');
});
byId('clientCancel').addEventListener('click',()=>{ byId('clientEditor').style.display='none'; });
byId('clientDelete').addEventListener('click',()=>{
  const sel=byId('clientSelect'); const cur=sel.value; if(CLIENTS[cur]){ delete CLIENTS[cur]; saveClients(); loadClients(); byId('clientEditor').style.display='none'; toast('Client deleted.'); }
});

/* ====== Init ====== */
(function init(){
  // Toast starts hidden
  byId('toast').style.opacity='0';
  sanitizeInputs();
  updateSwatches();
  renderHist();
  renderSOP();
  byId('subsText').textContent=SUBSTRATES[byId('substrate').value].name;
  if(!hasFS){ const hint=byId('heatmapHint'); if(hint) hint.textContent='Tip: Your browser does not support folder watching. Use the drag & drop zone to ingest spectro CSVs.'; }
  else { const hint=byId('heatmapHint'); if(hint) hint.textContent='Heatmap is DPI‑scaled for crispness. Folder bridge is active‑capable.'; }
  ensureGridStats();
  loadClients();
  
  // Initialize Pantone library display and presets
  if(window.pantoneColors && window.pantoneColors.colors) {
    console.log(`Pantone library loaded: ${window.pantoneColors.colors.length} colors`);
    toast(`Pantone library loaded: ${window.pantoneColors.colors.length} colors`);
    populatePantonePresets();
  }
})();
</script>
</body>
</html>